<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MapLibre: GSI/OSM basemap switch + hillshade + terrain</title>

  <!-- MapLibre (latest) -->
  <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.css" />
  <script src="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { position: absolute; inset: 0; }

    /* Small, collapsible control panel */
    .panel {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      font: 12px/1.3 system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      color: #111;
      max-width: 320px;
    }
    details.ctrl {
      background: rgba(255,255,255,0.92);
      border: 1px solid rgba(0,0,0,0.15);
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 6px 20px rgba(0,0,0,0.12);
    }
    details.ctrl > summary {
      cursor: pointer;
      padding: 8px 10px;
      user-select: none;
      list-style: none;
      font-weight: 600;
    }
    details.ctrl > summary::-webkit-details-marker { display: none; }
    .ctrl-body { padding: 10px; display: grid; gap: 10px; }

    .row { display: grid; gap: 6px; }
    .row label { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
    select, input[type="range"] { width: 100%; }
    .mini {
      font-size: 11px;
      color: #444;
    }
    .inline {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
    }
    .inline > * { flex: 1; }
    .value-badge {
      display: inline-block;
      min-width: 44px;
      text-align: right;
      font-variant-numeric: tabular-nums;
      color: #222;
    }

    /* Make MapLibre attribution a bit tighter */
    .maplibregl-ctrl-attrib { font-size: 11px; }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="panel">
    <details class="ctrl" open>
      <summary>地図/レイヤ（折りたたみ可）</summary>
      <div class="ctrl-body">

        <div class="row">
          <div class="mini">ベースマップ</div>
          <select id="basemapSelect">
            <option value="gsi_opt_vt">国土地理院 最適化ベクトルタイル</option>
            <option value="gsi_std">国土地理院 標準地図</option>
            <option value="gsi_pale">国土地理院 淡色地図</option>
            <option value="gsi_photo">国土地理院 写真地図（seamlessphoto）</option>
            <option value="osm_raster">OpenStreetMap ラスタタイル</option>
            <option value="osm_vt_bright_ja">OpenStreetMap ベクタタイル（osm-bright-ja）</option>
          </select>
        </div>

        <div class="row">
          <div class="mini">陰影起伏図（オーバーレイ）</div>
          <label class="inline">
            <span>
              <input id="hillshadeEnabled" type="checkbox" checked />
              有効
            </span>
            <span class="mini" style="text-align:right;">
              ブレンド:
              <select id="hillshadeBlend" style="width:auto;">
                <option value="normal">通常</option>
                <option value="multiply">乗算</option>
              </select>
            </span>
          </label>

          <label>
            <span>透過率</span>
            <span class="value-badge"><span id="hillshadeOpacityVal">0.55</span></span>
          </label>
          <input id="hillshadeOpacity" type="range" min="0" max="1" step="0.01" value="0.55" />
          <div class="mini">※ 陰影起伏図: hillshademap</div>
        </div>

        <div class="row">
          <div class="mini">地形（terrain: GSI DEM → Terrain-RGB 変換）</div>
          <label class="inline">
            <span>
              <input id="terrainEnabled" type="checkbox" />
              立体化を有効
            </span>
            <span class="mini" style="text-align:right;">
              ピッチ: <button id="pitchBtn" type="button" style="width:auto;">45°</button>
            </span>
          </label>

          <label>
            <span>誇張（0.1〜2.0）</span>
            <span class="value-badge"><span id="terrainExagVal">1.00</span></span>
          </label>
          <input id="terrainExag" type="range" min="0.1" max="2" step="0.01" value="1.0" />
          <div class="mini">
            DEMは `dem_png` を使用し、クライアント側で Mapbox Terrain-RGB 形式へ変換します。
          </div>
        </div>

        <div class="row">
          <div class="mini">初期中心: [139.875, 39.077]</div>
        </div>

      </div>
    </details>
  </div>

  <script>
    // ------------------------------
    // Basemap definitions
    // ------------------------------
    // Raster tiles (GSI / OSM)
    const TILES = {
      gsi_std:   "https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png",
      gsi_pale:  "https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png",
      gsi_photo: "https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg",
      osm_raster:"https://tile.openstreetmap.org/{z}/{x}/{y}.png",

      // Hillshade overlay (GSI)
      gsi_hillshade: "https://cyberjapandata.gsi.go.jp/xyz/hillshademap/{z}/{x}/{y}.png",

      // DEM PNG (GSI)
      gsi_dem_png: "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png"
    };

    // Vector styles
    const VECTOR_STYLES = {
      // OSM vector style (user-specified)
      osm_vt_bright_ja: "https://tile.openstreetmap.jp/styles/maptiler-basic-ja/style.json",

      // GSI optimized vector tile style:
      // NOTE: This URL follows the public demo repository structure.
      // If it ever changes, update this single URL.
      gsi_opt_vt: "https://gsi-cyberjapan.github.io/optimal_bvmap/style/std.json"
    };

    function makeRasterStyle(styleName, tileUrl, attributionHtml) {
      return {
        version: 8,
        glyphs: "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
        sources: {
          baseraster: {
            type: "raster",
            tiles: [tileUrl],
            tileSize: 256,
            attribution: attributionHtml || ""
          }
        },
        layers: [
          {
            id: "baseraster-layer",
            type: "raster",
            source: "baseraster"
          }
        ]
      };
    }

    const RASTER_STYLES = {
      gsi_std: makeRasterStyle(
        "gsi_std",
        TILES.gsi_std,
        '国土地理院'
      ),
      gsi_pale: makeRasterStyle(
        "gsi_pale",
        TILES.gsi_pale,
        '国土地理院'
      ),
      gsi_photo: makeRasterStyle(
        "gsi_photo",
        TILES.gsi_photo,
        '国土地理院'
      ),
      osm_raster: makeRasterStyle(
        "osm_raster",
        TILES.osm_raster,
        '&copy; OpenStreetMap contributors'
      )
    };

    // ------------------------------
    // State
    // ------------------------------
    const state = {
      basemap: "gsi_opt_vt",

      hillshade: {
        enabled: true,
        opacity: 0.55,
        blend: "normal" // "normal" | "multiply"
      },

      terrain: {
        enabled: false,
        exaggeration: 1.0
      }
    };

    // ------------------------------
    // Map init
    // ------------------------------
    const map = new maplibregl.Map({
      container: "map",
      style: VECTOR_STYLES[state.basemap],
      center: [139.875, 39.077],
      zoom: 8.5,
      pitch: 0,
      bearing: 0,
      maxPitch: 85
    });

    map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), "top-right");
    map.addControl(new maplibregl.ScaleControl({ maxWidth: 120, unit: "metric" }), "bottom-left");

    // ------------------------------
    // DEM: GSI dem_png -> Mapbox Terrain-RGB conversion via addProtocol
    // ------------------------------
    // GSI DEM PNG spec (summary):
    // x = 2^16*R + 2^8*G + B
    // u=0.01m; if x < 2^23 => h = x*u; if x==2^23 => NA; if x > 2^23 => h=(x-2^24)*u
    // NA pixel is (128,0,0)
    //
    // Terrain-RGB encoding (Mapbox):
    // enc = (height_m + 10000) * 10
    // R=floor(enc/65536), G=floor((enc%65536)/256), B=enc%256
    //
    // MapLibre v4 addProtocol is Promise-based.
    maplibregl.addProtocol("gsidem", async (params, abortController) => {
      const srcUrl = params.url.replace("gsidem://", "");

      const res = await fetch(srcUrl, { signal: abortController.signal, mode: "cors" });
      if (!res.ok) throw new Error("DEM tile fetch failed: " + res.status);

      const blob = await res.blob();
      const bmp = await createImageBitmap(blob);

      const canvas = document.createElement("canvas");
      canvas.width = bmp.width;
      canvas.height = bmp.height;
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      ctx.drawImage(bmp, 0, 0);

      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const d = img.data;

      // Convert each pixel in-place to Terrain-RGB
      for (let i = 0; i < d.length; i += 4) {
        const r = d[i + 0];
        const g = d[i + 1];
        const b = d[i + 2];

        let heightM = 0;
        const isNA = (r === 128 && g === 0 && b === 0);

        if (isNA) {
          // Set sea-level-ish for missing data (avoid spikes)
          heightM = 0;
        } else {
          const x = (r << 16) + (g << 8) + b; // 0..16777215
          const TWO_23 = 1 << 23; // 8388608
          const TWO_24 = 1 << 24; // 16777216
          const u = 0.01;

          if (x === TWO_23) {
            heightM = 0; // NA
          } else if (x < TWO_23) {
            heightM = x * u;
          } else {
            heightM = (x - TWO_24) * u; // negative
          }
        }

        // Encode to Terrain-RGB (Mapbox)
        let enc = Math.round((heightM + 10000) * 10); // 0.1m steps
        if (enc < 0) enc = 0;
        if (enc > 16777215) enc = 16777215;

        d[i + 0] = (enc >> 16) & 255;
        d[i + 1] = (enc >> 8) & 255;
        d[i + 2] = enc & 255;
        // alpha kept as-is
      }

      ctx.putImageData(img, 0, 0);

      const outBlob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
      const arrayBuffer = await outBlob.arrayBuffer();
      return { data: arrayBuffer };
    });

    // ------------------------------
    // Overlay / terrain install helpers
    // ------------------------------
    const HILLSHADE_SOURCE_ID = "gsi-hillshade";
    const HILLSHADE_LAYER_ID  = "gsi-hillshade-layer";

    const DEM_SOURCE_ID = "gsi-dem-rgb";

    function ensureHillshade() {
      if (!map.getSource(HILLSHADE_SOURCE_ID)) {
        map.addSource(HILLSHADE_SOURCE_ID, {
          type: "raster",
          tiles: [TILES.gsi_hillshade],
          tileSize: 256,
          attribution: "国土地理院"
        });
      }
      if (!map.getLayer(HILLSHADE_LAYER_ID)) {
        // Put it near the top so it works as an overlay regardless of style.
        // If some styles use "sky"/"symbol" etc, this still draws above most layers.
        const beforeId = findTopmostSymbolLayerId() || undefined;

        map.addLayer({
          id: HILLSHADE_LAYER_ID,
          type: "raster",
          source: HILLSHADE_SOURCE_ID,
          paint: {
            "raster-opacity": state.hillshade.opacity,
            "raster-blend-mode": state.hillshade.blend
          }
        }, beforeId);
      }

      map.setLayoutProperty(
        HILLSHADE_LAYER_ID,
        "visibility",
        state.hillshade.enabled ? "visible" : "none"
      );
      map.setPaintProperty(HILLSHADE_LAYER_ID, "raster-opacity", state.hillshade.opacity);
      map.setPaintProperty(HILLSHADE_LAYER_ID, "raster-blend-mode", state.hillshade.blend);
    }

    function ensureTerrain() {
      if (!map.getSource(DEM_SOURCE_ID)) {
        map.addSource(DEM_SOURCE_ID, {
          type: "raster-dem",
          tiles: ["gsidem://" + TILES.gsi_dem_png],
          tileSize: 256,
          maxzoom: 14,
          attribution: "国土地理院"
        });
      }

      if (state.terrain.enabled) {
        map.setTerrain({ source: DEM_SOURCE_ID, exaggeration: state.terrain.exaggeration });
      } else {
        map.setTerrain(null);
      }
    }

    function findTopmostSymbolLayerId() {
      const layers = map.getStyle()?.layers || [];
      // Find first symbol layer from top (reverse) and insert before it,
      // so the hillshade doesn't cover labels.
      for (let i = layers.length - 1; i >= 0; i--) {
        if (layers[i].type === "symbol") return layers[i].id;
      }
      return null;
    }

    function applyAll() {
      ensureTerrain();
      ensureHillshade();
    }

    map.on("style.load", () => {
      // After any setStyle, re-apply overlays/terrain
      applyAll();
    });

    map.on("load", () => {
      applyAll();
      wireUI();
    });

    // ------------------------------
    // UI wiring
    // ------------------------------
    function wireUI() {
      const basemapSelect = document.getElementById("basemapSelect");
      const hillshadeEnabled = document.getElementById("hillshadeEnabled");
      const hillshadeOpacity = document.getElementById("hillshadeOpacity");
      const hillshadeOpacityVal = document.getElementById("hillshadeOpacityVal");
      const hillshadeBlend = document.getElementById("hillshadeBlend");

      const terrainEnabled = document.getElementById("terrainEnabled");
      const terrainExag = document.getElementById("terrainExag");
      const terrainExagVal = document.getElementById("terrainExagVal");
      const pitchBtn = document.getElementById("pitchBtn");

      // Init UI from state
      basemapSelect.value = state.basemap;
      hillshadeEnabled.checked = state.hillshade.enabled;
      hillshadeOpacity.value = state.hillshade.opacity;
      hillshadeOpacityVal.textContent = state.hillshade.opacity.toFixed(2);
      hillshadeBlend.value = state.hillshade.blend;

      terrainEnabled.checked = state.terrain.enabled;
      terrainExag.value = state.terrain.exaggeration;
      terrainExagVal.textContent = state.terrain.exaggeration.toFixed(2);

      basemapSelect.addEventListener("change", () => {
        state.basemap = basemapSelect.value;

        if (RASTER_STYLES[state.basemap]) {
          map.setStyle(RASTER_STYLES[state.basemap]);
        } else {
          map.setStyle(VECTOR_STYLES[state.basemap]);
        }
        // overlays/terrain will be re-applied on style.load
      });

      hillshadeEnabled.addEventListener("change", () => {
        state.hillshade.enabled = hillshadeEnabled.checked;
        if (map.getLayer(HILLSHADE_LAYER_ID)) {
          map.setLayoutProperty(HILLSHADE_LAYER_ID, "visibility", state.hillshade.enabled ? "visible" : "none");
        } else {
          applyAll();
        }
      });

      hillshadeOpacity.addEventListener("input", () => {
        state.hillshade.opacity = Number(hillshadeOpacity.value);
        hillshadeOpacityVal.textContent = state.hillshade.opacity.toFixed(2);
        if (map.getLayer(HILLSHADE_LAYER_ID)) {
          map.setPaintProperty(HILLSHADE_LAYER_ID, "raster-opacity", state.hillshade.opacity);
        }
      });

      hillshadeBlend.addEventListener("change", () => {
        state.hillshade.blend = hillshadeBlend.value;
        if (map.getLayer(HILLSHADE_LAYER_ID)) {
          map.setPaintProperty(HILLSHADE_LAYER_ID, "raster-blend-mode", state.hillshade.blend);
        }
      });

      terrainEnabled.addEventListener("change", () => {
        state.terrain.enabled = terrainEnabled.checked;
        ensureTerrain();
        // Optional: if enabling, raise pitch a bit for effect
        if (state.terrain.enabled && map.getPitch() < 20) map.easeTo({ pitch: 45, duration: 500 });
        if (!state.terrain.enabled) map.easeTo({ pitch: 0, duration: 300 });
      });

      terrainExag.addEventListener("input", () => {
        state.terrain.exaggeration = Number(terrainExag.value);
        terrainExagVal.textContent = state.terrain.exaggeration.toFixed(2);
        if (state.terrain.enabled) {
          map.setTerrain({ source: DEM_SOURCE_ID, exaggeration: state.terrain.exaggeration });
        }
      });

      pitchBtn.addEventListener("click", () => {
        const p = map.getPitch();
        const next = (p < 1) ? 45 : (p < 50 ? 70 : 0);
        map.easeTo({ pitch: next, duration: 450 });
        pitchBtn.textContent = next + "°";
      });
    }
  </script>
</body>
</html>
